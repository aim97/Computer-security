# Chapter 8: Public key cryptography based on Discrete Logarithm Problem

This section requires knowledge of [group theory](../Math/group-theory.md) before hand.

## DLP: Discrete Logarithm Problem
- this is the one way function based on which many cryptography schemes are made including but not limited to the ones mentioned here.
### Problem statment

![Generalized DLP](../images/ch8-DH-generalised-DLP.png)

- It's easy to compute *&beta;* given *&prop;* and *x*, but computing the *logarithm x = log*&prop;*(*&beta;*)* is the hard problem.

- DLP is based on [group theory](../Math/group-theory.md), the difficulty of the DLP is that you can't mathematically solve it, you need to examine all the possible numbers that can be generated by element *&prop;* while counting the steps needed to reach *&beta;* which is *x*. so the security of DLP depends on the number of elements that can be generated from *&prop;*, as minimum number required depends on the nature of the group.

- DLP is solved for groups using *simple addition* operation in mod m, it can be reduced to computing the inverse problem, as long as the chosen *generator* coprimes with m, we can solve it directly as
_<p align='center'>x = &prop;<sup>-1</sup> &beta; mod m</p>_


## Deffie-Hellman key exchange algorithm
![](../images/ch8-DH-init.png)
![](../images/ch8-DH-process.png)

- Deffie-Hellman is based on Group &Zopf;*<sub>_p_</sub>

## Attacks against Deffie Hellman

### Generic Methods
Attack the generalized DLP not specific to certain groups
#### 1 - Brute Force
- Apply the operation to *&prop;* repeatedly until *&beta;* is reached, the number of iterations needed is x.
- Its complexity is &Oopf;(*ord(&prop;)*), using a primitive element this is essentially &Oopf;(*|G|*).
- So this attack fails if *|G|* is >= 2<sup>80</sup>.

#### 2 - Shank's method (Baby step Giant Step)
- A divide and Conquer approach
Let m = &radic;(*|G|*).  
we can define x as x = x<sub>g</sub> m + x<sub>b</sub>  
now the DLP can be written as  
_&prop;<sup>x<sub>b<sub></sup> &equiv; &beta; &prop;<sup>-m x<sub>g<sub></sup>_  

1. Generate all possible values of x<sub>b</sub> &isin; [0 .. m-1].
2. compute values of _&beta; &prop;<sup>-m x<sub>g<sub></sup>_ &isin; [0 .. m], for each value check if it exists in the generated values in previous step, and stop once found.
   
- Complexity = &Oopf;(&radic;*|G|*)
- to safeguard against this attack *|G|* should be >= 2<sup>160</sup>.

#### 3 - Pollard Rho Method
- Based on Brithday Paradox
- Randomly generate numbers of the form _&prop;<sup>i</sup>&beta;<sup>j</sup>_
  given that _&beta; = &prop; <sup>x<sup>_, then the previous form can be written as _&prop;<sup>i</sup>&beta;<sup>xj</sup>_
- Wait until a collision is found, then  
  _&prop;<sup>i<sub>1</sub> + x j<sub>1</sub></sup> = &prop; <sup>i<sub>2</sub> + x j<sub>2</sub></sup> &#8195;&#8195; mod |G|_  
  _i<sub>1</sub> + x j<sub>1</sub> = i<sub>2</sub> + x j<sub>2</sub> &#8195;&#8195; mod &phi;(|G|)_  
  _x = (i<sub>2</sub> - i<sub>1</sub> ). (j<sub>1</sub> - j<sub>2</sub>)<sup>-1</sup> &#8195;&#8195; mod &phi;(|G|)_  

- It's the best known attack for elliptic curve cryptosystems.  
- Complexity = &Oopf;(&radic;*|G|*).
- to safeguard against this attack *|G|* should be >= 2<sup>160</sup>.

#### 4 - Polhig Hellman method
- Based on chinease remainder method.
- Used as a preprocessing step for other methods to make them faster.
- It's a divide and Conquer algorithm, it defines |G| as  
  _|G| = p<sub>1</sub><sup>e<sub>1</sub></sup> p<sub>2</sub><sup>e<sub>2</sub></sup> p<sub>3</sub><sup>e<sub>3</sub></sup> p<sub>4</sub><sup>e<sub>4</sub></sup> ... p<sub>n</sub><sup>e<sub>n</sub></sup>_

- Use any of the above methods to solve DLP in smaller sub groups G(p<sub>i</sub><sup>e<sub>i</sub></sup>).
- Then combine the results to compute _x_ using chinease remainder method.

### Non-Generic Algorithms
Attacks that are specific to certain groups or under certain conditions

#### Index Calculus Method
- It targets groups _Z*<sub>p</sub>_ and _GF(2<sup>m</sup>)_.
- It works in groups where large elements can be represented as a product of small elements.
- This is a very strong attack, but doesn't work on elliptic curve cryptosystems.
- to safeguard against this attack *|G|* should be >= 2<sup>1024</sup>.

### Security of DHKE
![GDH](../images/ch8-DHP.png)

- Group size must be >= _2<sup>1024</sup>_ for _DHKE_ to be secure
- IT'S NOT SECURE AGAINST _ACTIVE ATTACKS_ like: _replay_, _generating false messages_, and _message modification_.

## Elgammal Encryption scheme
![Elgammal Encryption Scheme](../images/Ch8-Elgammal.png)
The above is a simple representation of the algorithm, that uses DHKE to exchange the key, then encrypt the message with simple multiplication then.

The actual scheme is as follows:
![Elgammal Protocol](../images/Ch8-Elgammal-protocol.png)
- Since K <sub>m</sub> is multiplied with x, it's called a _Masking key_.
- it's a probablisitic scheme, running the algorithm multiple times should have different result, depending on the chosen value for i, the private key of alice, which is changed every time a message is sent.  
- The protocol is used to transfer messages in one direction, you need to have a different process for the other direction to send messages as well.
- This method needs to send double the amount of data since the K <sub>E</sub> needs to be sent with _y_ to the other side.
- Unlike DHKE, the parameters _p_ and _&prop;_ are generated by one of the two involved parties and not a trusted thrid party.
